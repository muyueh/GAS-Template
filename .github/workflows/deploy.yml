name: Deploy to Apps Script

on:
  push:
    branches: ["main"]
    tags:
      - "v*"
  workflow_dispatch:

concurrency:
  group: "apps-script-deploy"
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Evaluate deploy readiness
        id: gas
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const statePath = '.gas/state.json';
          const claspPath = '.clasp.json';

          const readScriptId = (value) => {
            const id = (value || '').trim();
            return id && id !== 'REPLACE_WITH_SCRIPT_ID' ? id : '';
          };

          let ready = false;
          let scriptId = '';
          let reason = '';
          let rootDir = 'dist';

          if (fs.existsSync(statePath)) {
            try {
              const state = JSON.parse(fs.readFileSync(statePath, 'utf8'));
              const candidate = readScriptId(state.gas?.scriptId);
              const verified = Boolean(state.auth?.verified);
              if (candidate && verified) {
                ready = true;
                scriptId = candidate;
                rootDir = state.gas?.rootDir || rootDir;
              } else {
                reason = 'state.json present but missing verified auth or scriptId';
              }
            } catch (error) {
              reason = `state.json invalid: ${error.message}`;
            }
          }

          if (!ready && fs.existsSync(claspPath)) {
            try {
              const clasp = JSON.parse(fs.readFileSync(claspPath, 'utf8'));
              const candidate = readScriptId(clasp.scriptId);
              if (candidate) {
                ready = true;
                scriptId = candidate;
                rootDir = clasp.rootDir || rootDir;
              } else if (!reason) {
                reason = '.clasp.json present but missing scriptId';
              }
            } catch (error) {
              reason = `.clasp.json invalid: ${error.message}`;
            }
          }

          if (!ready && !reason) {
            reason = 'No bootstrap state or .clasp.json with a valid scriptId found';
          }

          const outputs = {
            ready,
            scriptId,
            rootDir,
            reason,
          };

          const out = Object.entries(outputs)
            .map(([key, value]) => `${key}=${String(value).replace(/%/g, '%25').replace(/\n/g, '%0A').replace(/\r/g, '%0D')}`)
            .join('\n');
          fs.appendFileSync(process.env.GITHUB_OUTPUT, `${out}\n`);

          if (ready) {
            console.log(`Deploy ready: scriptId=${scriptId}, rootDir=${rootDir}`);
          } else {
            console.warn(`Deploy skipped: ${reason}`);
          }
          NODE

      - name: Skip deploy (not ready)
        if: steps.gas.outputs.ready != 'true'
        run: |
          {
            echo "### ⚠️ Deploy skipped" >> "$GITHUB_STEP_SUMMARY"
            echo "- Reason: ${{ steps.gas.outputs.reason }}" >> "$GITHUB_STEP_SUMMARY"
            echo "- Action: merge the bootstrap PR from gas-bootstrap.yml or add a valid .clasp.json" >> "$GITHUB_STEP_SUMMARY"
          }
          exit 0

      - name: Ensure clasp config exists
        if: steps.gas.outputs.ready == 'true'
        env:
          SCRIPT_ID: ${{ steps.gas.outputs.scriptId }}
          ROOT_DIR: ${{ steps.gas.outputs.rootDir }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = '.clasp.json';
          const scriptId = (process.env.SCRIPT_ID || '').trim();
          const rootDir = process.env.ROOT_DIR || 'dist';
          if (!scriptId) {
            throw new Error('scriptId missing from readiness evaluation');
          }
          let existingRoot = rootDir;
          try {
            const current = JSON.parse(fs.readFileSync(path, 'utf8'));
            existingRoot = current.rootDir || existingRoot;
          } catch (error) {
            // overwrite with known good values
          }
          fs.writeFileSync(path, JSON.stringify({ scriptId, rootDir: existingRoot }, null, 2));
          console.log(`Using scriptId ${scriptId} with rootDir ${existingRoot}`);
          NODE

      - name: Validate clasp auth secret
        if: steps.gas.outputs.ready == 'true'
        env:
          CLASPRC_JSON: ${{ secrets.CLASPRC_JSON }}
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const path = `${process.env.HOME}/.clasprc.json`;
          const source = process.env.CLASPRC_JSON ?? '';

          if (!source.trim()) {
            throw new Error(
              "Missing CLASPRC_JSON secret. Run 'npx clasp login --no-localhost' and paste the Base64 block from 'npm run check:clasprc -- --print --base64' into the CLASPRC_JSON repository secret (raw JSON is also accepted)."
            );
          }

          const attemptParse = (value) => {
            try {
              return JSON.parse(value);
            } catch (error) {
              return undefined;
            }
          };

          const decodeClasprc = (raw) => {
            const trimmed = raw.trim();
            if (!trimmed) {
              throw new Error(
                'CLASPRC_JSON is set but empty. Paste the Base64 block from `npm run check:clasprc -- --print --base64` (preferred) or the raw ~/.clasprc.json content.'
              );
            }

            let decodedRaw = trimmed;
            let format = 'json';
            let data = attemptParse(decodedRaw);

            if (!data) {
              try {
                const maybeDecoded = Buffer.from(trimmed, 'base64')
                  .toString('utf8')
                  .trim();
                if (maybeDecoded) {
                  const maybeParsed = attemptParse(maybeDecoded);
                  if (maybeParsed) {
                    decodedRaw = maybeDecoded;
                    data = maybeParsed;
                    format = 'base64';
                  }
                }
              } catch (error) {
                // continue to unified failure below
              }
            }

            if (!data) {
              throw new Error(
                'Failed to parse CLASPRC_JSON as JSON or base64-encoded JSON. Regenerate with `npm run check:clasprc -- --print --base64` and paste the Base64 block into the secret.'
              );
            }

            return { data, decodedRaw, format };
          };

          const { data, decodedRaw, format } = decodeClasprc(source);

          fs.writeFileSync(path, decodedRaw, 'utf8');

          const pickFirst = (...candidates) =>
            candidates.find((value) => typeof value === 'string' && value.trim())?.trim();

          const pickFromTokens = (fieldNames) => {
            const tokens = data.tokens;
            if (!tokens || typeof tokens !== 'object') return [];

            const ordered = [];
            if (tokens.default && typeof tokens.default === 'object') ordered.push(tokens.default);
            for (const [key, token] of Object.entries(tokens)) {
              if (key === 'default') continue;
              if (token && typeof token === 'object') ordered.push(token);
            }

            const out = [];
            for (const token of ordered) {
              for (const name of fieldNames) {
                const value = token[name];
                if (typeof value === 'string' && value.trim()) {
                  out.push(value.trim());
                  break;
                }
              }
            }
            return out;
          };

          const refreshToken = pickFirst(
            data.refresh_token,
            data.token?.refresh_token,
            data.token?.refreshToken,
            ...pickFromTokens(['refresh_token', 'refreshToken'])
          );

          const clientId = pickFirst(
            data.clientId,
            data.oauth2ClientSettings?.clientId,
            data.client_id,
            ...pickFromTokens(['clientId', 'client_id'])
          );

          const clientSecret = pickFirst(
            data.clientSecret,
            data.oauth2ClientSettings?.clientSecret,
            data.client_secret,
            ...pickFromTokens(['clientSecret', 'client_secret'])
          );

          const missing = [];
          if (!refreshToken) missing.push('refresh_token');
          if (!clientId) missing.push('clientId');
          if (!clientSecret) missing.push('clientSecret');

          if (missing.length) {
            throw new Error(
              `Incomplete clasp credentials: missing ${missing.join(
                ', '
              )}. Re-run 'npx clasp login --no-localhost' and paste the Base64 block from \`npm run check:clasprc -- --print --base64\` into the CLASPRC_JSON secret (raw JSON also works).`
            );
          }

          console.log(
            `✅ CLASPRC_JSON looks valid and contains required tokens (${format}).`
          );
          NODE

      - name: Install
        if: steps.gas.outputs.ready == 'true'
        run: npm ci

      - name: Build
        if: steps.gas.outputs.ready == 'true'
        run: npm run build

      - name: clasp push
        if: steps.gas.outputs.ready == 'true'
        run: npx clasp push -f

      - name: clasp deploy (tag/workflow_dispatch only)
        if: steps.gas.outputs.ready == 'true' && (startsWith(github.ref, 'refs/tags/') || github.event_name == 'workflow_dispatch')
        env:
          CLASP_DEPLOYMENT_ID: ${{ secrets.CLASP_DEPLOYMENT_ID }}
        run: |
          DESC="CI deploy ${GITHUB_REF_NAME:-manual} @ ${GITHUB_SHA}"
          if [ -n "$CLASP_DEPLOYMENT_ID" ]; then
            npx clasp deploy -i "$CLASP_DEPLOYMENT_ID" -d "$DESC"
          else
            npx clasp deploy -d "$DESC"
          fi
